<div align="center"><img src="https://gitee.com/struggle3014/picBed/raw/master/name_code.png"></div>

# 导读

本文介绍二叉树相关的知识。

***持续更新中~***



# 目录

<nav>
<a href='#导读' style='text-decoration:none;font-weight:bolder'>导读</a><br/>
<a href='#目录' style='text-decoration:none;font-weight:bolder'>目录</a><br/>
<a href='#正文' style='text-decoration:none;font-weight:bolder'>正文</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href='#定义' style='text-decoration:none;${border-style}'>定义</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href='#基本操作' style='text-decoration:none;${border-style}'>基本操作</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#深度优先遍历' style='text-decoration:none;${border-style}'>深度优先遍历</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#宽度优先遍历' style='text-decoration:none;${border-style}'>宽度优先遍历</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#树的最大宽度' style='text-decoration:none;${border-style}'>树的最大宽度</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href='#序列化与反序列化' style='text-decoration:none;${border-style}'>序列化与反序列化</a><br/>
<a href='#总结' style='text-decoration:none;font-weight:bolder'>总结</a><br/>
<a href='#参考文献' style='text-decoration:none;font-weight:bolder'>参考文献</a><br/>
</nav>

# 正文

## 定义

下图展示了二叉树 T 中如何利用属性 p，left 和 right 存放指向父节点、左孩子和右孩子的指针。如果 x.p = NIL，则 x 是根节点。如果节点 x 没有左孩子，则 x.left = NIL，右孩子的情况与此类似。属性 T.root 指向整棵树 T 的根节点。如果 T.root = NIL，则该树为空。

![二叉树](https://gitee.com/struggle3014/picBed/raw/master/二叉树.png)

<div align="center"><font size="2">二叉树</font></div>

## 基本操作

### 深度优先遍历

树的深度优先遍历可以使用树的**递归序**实现。

[RecursiveTraversalBT#recursiveOrder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code02_RecursiveTraversalBT.java)

![递归序实现深度优先遍历](https://gitee.com/struggle3014/picBed/raw/master/递归序实现深度优先遍历.png)

<div align="center"><font size="2">递归序实现深度优先遍历</font></div>



#### 先序遍历（头左右）

子树根的关键字在其左右子树的关键字值之间。

* 递归方式

  [RecursiveTraversalBT#preorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code02_RecursiveTraversalBT.java)

* 非递归方式

  [NonRecursiveTraversalBT#preorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code03_NonRecursiveTraversalBT.java)

  ![先序遍历（递归方式）](https://gitee.com/struggle3014/picBed/raw/master/先序遍历（递归方式）.png)
  
  <div align="center"><font size="2">先序遍历（非递归方式）</font></div>



#### 中序遍历（左头右）

子树根的关键字位于其左子树的关键字值和右子树关键字值之间。

* 递归方式

  [RecursiveTraversalBT#inorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code02_RecursiveTraversalBT.java)

* 非递归方式

  [NonRecursiveTraversalBT#inorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code03_NonRecursiveTraversalBT.java)



#### 后续遍历（左右头）

子树跟的关键字在其左右子树的关键字值之后。

* 递归方式

  [RecursiveTraversalBT#postorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code02_RecursiveTraversalBT.java)

* 非递归方式

  [NonRecursiveTraversalBT#postorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code03_NonRecursiveTraversalBT.java)



### 宽度优先遍历

[LevelTraversalBT#level](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code04_LevelTraversalBT.java)



### 树的最大宽度

[TreeMaxWidth#maxWidth](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code05_TreeMaxWidth.java)



### 序列化与反序列化

#### 深度优先方式的序列化与反序列化

| 遍历方式 | 序列化                                                       | 反序列化                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 先序     | [SerializeDeserializeTree#serializeByPreorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) | [SerializeDeserializeTree#deserializeByPreorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) |
| 中序     | [SerializeDeserializeTree#serializeByInorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) | [SerializeDeserializeTree#serializeByPreorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) |
| 后序     | [SerializeDeserializeTree#serializeByPostorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) | [SerializeDeserializeTree#deserializeByPostorder](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java) |



#### 宽度优先方式的序列化与反序列化

* 序列化

  [SerializeDeserializeTree#serializeByLevel](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java)

* 反序列化

  [SerializeDeserializeTree#deserializeByLevel](../../../../projects/alogorithm-basic/src/main/java/com/xiumei/datastructure/tree/Code06_SerializeDeserializeTree.java)



# 总结



# 参考文献

[1] [《算法导论》，第三版，Thomas H.Cormen，机械工业出版社](https://99baiduyun.com/baidu/算法导论)

