# 导读

选择排序（Selection Sort）是一种简单直观的排序算法。



# 目录

[TOC]

# 正文

## 1 算法原理

在末排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。



## 2 算法实现

```java
/**
 * @Author: struggle3014
 * @Email: struggle3014@gmail.com
 * @Date: 14:49 2020/4/17
 * @Version: 1.0
 * @Description: 算法：选择排序实现
 **/
public class SelectionSort {

    public static void main(String[] args) {
        int[] arr = {5, 2, 8, 3, 7, 0, 9, 6, 4, 1};

        for(int i=0; i<arr.length - 1; i++) {
            // 假设位置i是数组中最小元素
            int minPos = i;
            for(int j=i+1; j<arr.length; j++) {
                minPos = arr[j] < arr[minPos] ? j : minPos;
//                if(arr[minPos] > arr[j]) {
//                    minPos = j;
//                }
            }
            // 执行交换
            swap(arr, i, minPos);
            System.out.println("经过第" + i + "循环之后，数组的内容：");
            for(int k=0; k<arr.length; k++) {
                System.out.print(arr[k] + " ");
            }
        }

    }

    /**
     * 数据交换，对应索引位置元素进行交换。
     * @param arr 数组
     * @param i 索引 i
     * @param j 索引 j
     */
    static void swap(int[] arr, int i, int j) {
        int temp = 0;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * 打印数组
     * @param arr 数组 arr
     */
    static void print(int[] arr) {
        for(int i=0; i<arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }

}
```



## 3 算法分析

| 中文名称 | 英文名称        | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | --------------- | -------------- | -------------- | -------------- | ---------- | ------ |
| 选择排序 | Selection  Sort | n^2            | n^2            | n^2            | 1          | 不稳定 |

* 优点
  * 选择排序与数据移动有关。
  * 如果某个元素位于正确的最终位置上，则它不会被移动。
  * 选择排序每次交换一对元素，它们当中至少有一个将被移动到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n-1 次交换。
  * 在所有的完全依赖交换去移动元素的排序方法中，选择排序属于非常好的一种。
* 缺点



## 4 改进

改进思路可从以下点考虑：

* 每次遍历找出最大和最小值。在选择排序中，每次遍历都是找出最小值，然后做交换，我们能否每次遍历找出最大值和最小值。这样可以少一半遍历操作。
* 每次遍历获取两个元素，找出其中的交小值与最小值比较。每次遍历时都是取出单个值和最小值做比较，是否可以考虑取出两个元素中的较小值与最小值作比较。

**上述改进思路的具体实现细节查看源码即可。**



# 总结





# 参考文献

[1] [选择排序，维基百科](https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

[2] [算法动画演示，旧金山大学](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)